1、探讨几种支持异步的流行框架，实现服务器端非阻塞请求处理

web应用服务器端处理请求传统的方式是同步的。如ajax，异步编程一般在客户端实现的。 随着社交网络、移动设备以及互联网新兴事件的出现，要想达到曾经令每个人望而却步的性能诉求，在服务器端通过异步处理来自客户端的请求已经变得越有越紧迫。事件驱动、非阻塞、响应式编程吸引了很多兴趣爱好者。声名鹊起的Node.js表明一个新时代已经开启.

对于每位java开发中来说幸运的是Java令人难以置信的方式证明能适应变化的世界。作为一门编程语言，Java对于异步编程方面的支持一直在稳步的发展，Java 1.4支持非阻塞I/O (NIO) ，Java 6 支持executor service，Java 7支持fork/join框架以及Java 8对Lambda（闭包）的支持。Servlet 3.0 开始加入Java EE 6来时，就加入了对异步处理请求的支持，因为servlets是需求Web应用的基础，所以对异步编程的的支持具有里程碑的意义.

很大的进步来自于开源社区，Akka、Spring Reactor、RxJava都致力于为事件驱动的响应式编程提供基础的API，许多开源框架已经增加了对异步编程的支持，例如Spring MVC 和 Grails等。此外，像 Play框架和Vert.x这些新一代轻量级的JVM web框架从一开始就是非阻塞模式的.

这篇文章探讨Servlet, JAX-RS, Spring MVC, Vert.x, 和the Play Framework这几种流行的web框架对异步编程的支持，这些框架表明在JVM生态系统里异步编程是普遍都倾向的选择，不管是从悠久的servlets到新崛起的Vert.x，还是简单的todosapp应用等这些框架，都展示了实现非阻塞web应用的示例.

2、为什么要用非阻塞处理方式

在传统的web应用中，每一个请求有一个单线程同步处理，这种简单的线程模式应经应用到许多传统的web应用中。

web应用的快速发展推动多边技术领域，服务器端来自 ajax，长轮询，数据流快速增长的请求就是所谓的C10K问题，而这其中大量的链接是由网络web应用引起的。如果我们继续为每个请求维护一个阻塞的线程，大量的线程带来的内存开销和多线程间上下文切换的开销会导致极其昂贵的代价。

非阻塞处理请求成为解决这个问题的有效途径，通过少量线程异步处理大量的请求，而不是一个阻塞线程处理一个请求。这种方式尽管增加了复杂性，但是能更有效的利用CPU和具有更好的扩展性。

异步处理的另外一个好处是它允许将工作负载分布到多核上，或者分布到多台服务器上。  第一次在计算机行业的历史上，摩尔定义已经不适用，CPU的速度已经到达它的物理极限。
